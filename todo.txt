### TODO:
//	* 需要一个用例去测试，多个连接开开关关，会不会真正完全都关闭了——主要关注连接的socket有没有都正常的关闭了。避免长期开启的fd资源耗尽
//		* 单独一个测试用例
//	* 测试40k个链接的可行性

//	* 跑随机数据数天看是否会崩溃或有数据不一致的问题。用家里多核cpu去跑
//	* 对应的消息文档(一些知识性质的整理)：可以写到doc里面
//		* 主要是指socket 和epoll相关使用。 懒得写博客了 直接写文档里面.
//	* 读写缓存设置分离，不设置最高最低，直接设单值.

### 一些单独demo测试的问题
//  * epoll 监听一个不存在的socket 和 监听一个已经close的socket 会产生什么情况？
//  * call close socket 是触发什么事件?
//  * 主连接断开后，观察其他连接是不是会自动断开?

### 后续有时间完善
	* client epoll版本的Connect等listen接口调用完善（当前是没有这些调用点的.）

### 多生产 多消费者: 考虑换掉lockqueue(回头看场景是否支持.)
	linux内核kqueue, 这个库支持任意长度的对象入库，代码不到百行，在linux中效率之高，令人叫赞。
	lockfree的实现(放在网关后面) 
		* boost lock_free_queue : 已确认boost 的lfquque不满足要求，需要自己写，或者找其他queue
